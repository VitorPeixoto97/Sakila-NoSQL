-- COMANDOS PARA REMOVER AS TABELAS PARA TESTES
drop table customer;
ALTER TABLE staff
DROP CONSTRAINT store_FK;
drop table store;
drop table staff;
drop table actor;
drop table address;
drop table category;
drop table city;
drop table country;


-- NOTAS: 
--
-- verfificar se precisamos de fazer alguma coisa para o caso do ON DELETE RESTRICT
-- (supostamente esta sintax representa o que já é o comportamento normal de uma
-- chave estrangeira, que é não poder eliminar o pai se existirem filhos)
--
-- perguntar se vale a pena implementar o ON UPDATE CASCADE porque na verdade as
-- chaves primárias não devem ser alteradas


CREATE TABLE actor (
  actor_id SMALLINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
  first_name VARCHAR(45) NOT NULL,
  last_name VARCHAR(45) NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT actor_PK PRIMARY KEY (actor_id));
CREATE INDEX actor_last_name_IDX ON actor (last_name);
CREATE OR REPLACE TRIGGER actor_timestamp_trigger
    BEFORE UPDATE ON actor
    FOR EACH ROW
    BEGIN
        :new.last_update := current_timestamp;
    END;
/

CREATE TABLE category (
  category_id SMALLINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
  name VARCHAR(25) NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT category_PK PRIMARY KEY (category_id));
CREATE OR REPLACE TRIGGER category_timestamp_trigger
    BEFORE UPDATE ON category
    FOR EACH ROW
    BEGIN
        :new.last_update := current_timestamp;
    END;
/

CREATE TABLE country (
  country_id SMALLINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
  country VARCHAR(50) NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT country_PK PRIMARY KEY (country_id));
CREATE OR REPLACE TRIGGER country_timestamp_trigger
    BEFORE UPDATE ON country
    FOR EACH ROW
    BEGIN
        :new.last_update := current_timestamp;
    END;
/

CREATE TABLE city (
  city_id SMALLINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
  city VARCHAR(50) NOT NULL,
  country_id SMALLINT NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT city_PK PRIMARY KEY (city_id),
  CHECK(country_id > 0));
CREATE INDEX city_country_id_IDX ON city (country_id);
CREATE OR REPLACE TRIGGER city_timestamp_trigger
    BEFORE UPDATE ON city
    FOR EACH ROW
    BEGIN
        :new.last_update := current_timestamp;
    END;
/

CREATE TABLE address (
  address_id SMALLINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
  address VARCHAR(50) NOT NULL,
  address2 VARCHAR(50) DEFAULT NULL,
  district VARCHAR(20) NOT NULL,
  city_id SMALLINT NOT NULL,
  postal_code VARCHAR(10) DEFAULT NULL,
  phone VARCHAR(20) NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT address_PK PRIMARY KEY (address_id),
  CHECK(city_id > 0));
CREATE INDEX address_city_id_IDX ON address (city_id);
CREATE OR REPLACE TRIGGER address_timestamp_trigger
    BEFORE UPDATE ON address
    FOR EACH ROW
    BEGIN
        :new.last_update := current_timestamp;
    END;
/

CREATE TABLE staff (
  staff_id SMALLINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
  first_name VARCHAR(45) NOT NULL,
  last_name VARCHAR(45) NOT NULL,
  address_id SMALLINT NOT NULL,
  picture CLOB DEFAULT NULL,
  email VARCHAR(50) DEFAULT NULL,
  store_id SMALLINT NOT NULL,
  active NUMBER(1,0) DEFAULT 1,
  username VARCHAR(16) NOT NULL,
  password CLOB DEFAULT NULL, -- O ORACLE NAO ACEITA VARCHAR BINARY... QUE ALTERNATIVAS HÁ??? ************* TESTAR CLOB NA MAQ VIRTUAL ******************
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT staff_PK PRIMARY KEY (staff_id),
  CHECK(staff_id > 0), 
  CHECK(address_id > 0),
  CHECK(store_id > 0));
CREATE INDEX staff_store_id_IDX ON staff (store_id);
CREATE INDEX staff_address_id_IDX ON staff (address_id);
CREATE OR REPLACE TRIGGER staff_timestamp_trigger
    BEFORE UPDATE ON staff
    FOR EACH ROW
    BEGIN
        :new.last_update := current_timestamp;
    END;
/

CREATE TABLE store (
  store_id SMALLINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
  manager_staff_id SMALLINT NOT NULL,
  address_id SMALLINT NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT store_PK PRIMARY KEY (store_id),
  CHECK(store_id > 0),
  CHECK(manager_staff_id > 0),
  CHECK(address_id > 0));
CREATE INDEX store_manager_staff_id_IDX ON store (manager_staff_id);
CREATE INDEX store_address_id_IDX ON store (address_id);
CREATE OR REPLACE TRIGGER store_timestamp_trigger
    BEFORE UPDATE ON store
    FOR EACH ROW
    BEGIN
        :new.last_update := current_timestamp;
    END;
/

CREATE TABLE customer (
  customer_id SMALLINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
  store_id SMALLINT NOT NULL,
  first_name VARCHAR(45) NOT NULL,
  last_name VARCHAR(45) NOT NULL,
  email VARCHAR(50) DEFAULT NULL,
  address_id SMALLINT NOT NULL,
  active NUMBER(1,0) DEFAULT 1,
  create_date DATE NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT customer_PK PRIMARY KEY (customer_id),
  CHECK(address_id > 0),
  CHECK(store_id > 0));
CREATE INDEX customer_store_id_IDX ON customer (store_id);
CREATE INDEX customer_last_name_IDX ON customer (last_name);
CREATE INDEX customer_address_id_IDX ON customer (address_id);
CREATE OR REPLACE TRIGGER customer_timestamp_trigger
    BEFORE UPDATE ON customer
    FOR EACH ROW
    BEGIN
        :new.last_update := current_timestamp;
    END;
/

CREATE TABLE film (
  film_id NUMBER(5,0) GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
  title VARCHAR(255) NOT NULL,
  description CLOB DEFAULT NULL,
  release_year NUMBER DEFAULT NULL,
  language_id NUMBER(5,0) NOT NULL,
  original_language_id NUMBER(5,0) DEFAULT NULL,
  rental_duration NUMBER(5,0) DEFAULT 3 NOT NULL,
  rental_rate DECIMAL(4,2) DEFAULT 4.99 NOT NULL,
  length NUMBER(5,0) DEFAULT NULL,
  replacement_cost DECIMAL(5,2) DEFAULT 19.99 NOT NULL,
  rating VARCHAR(10) DEFAULT 'G',
  special_features VARCHAR(64) DEFAULT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT film_PK PRIMARY KEY  (film_id),
  CHECK(rating IN ('G','PG','PG-13','R','NC-17')),
  CHECK(language_id > 0),
  CHECK(original_language_id > 0),
  CHECK(rental_duration > 0),
  CHECK(length > 0));
CREATE INDEX film_title_IDX ON film (title);
CREATE INDEX film_language_id_IDX ON film (language_id);
CREATE INDEX film_original_language_id_IDX ON film (original_language_id);
CREATE OR REPLACE TRIGGER film_timestamp_trigger
    BEFORE UPDATE ON film
    FOR EACH ROW
    BEGIN
        :new.last_update := current_timestamp;
    END;
/

CREATE TABLE film_actor (
  actor_id SMALLINT NOT NULL,
  film_id SMALLINT NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT film_actor_PK PRIMARY KEY (actor_id,film_id),
  CHECK(actor_id > 0),
  CHECK(film_id > 0));
CREATE INDEX film_actor_film_id_IDX ON film_actor (film_id);
CREATE OR REPLACE TRIGGER film_actor_timestamp_trigger
    BEFORE UPDATE ON film_actor
    FOR EACH ROW
    BEGIN
        :new.last_update := current_timestamp;
    END;
/

CREATE TABLE film_category (
  film_id SMALLINT NOT NULL,
  category_id SMALLINT NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT film_category_PK PRIMARY KEY (film_id,category_id),
  CHECK(film_id > 0),
  CHECK(category_id > 0));
CREATE OR REPLACE TRIGGER film_category_timestamp_trigger
    BEFORE UPDATE ON film_category
    FOR EACH ROW
    BEGIN
        :new.last_update := current_timestamp;
    END;
/

CREATE TABLE film_text (
  film_id SMALLINT NOT NULL,
  title VARCHAR(255) NOT NULL,
  description CLOB,
  CONSTRAINT film_text_PK PRIMARY KEY (film_id));

CREATE TABLE inventory (
  inventory_id NUMBER(7,0) GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
  film_id NUMBER(5,0) NOT NULL,
  store_id NUMBER(3,0) NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT inventory_PK PRIMARY KEY (inventory_id),
  CHECK(inventory_id>0),
  CHECK(film_id>0),
  CHECK(store_id>0));
CREATE INDEX inventory_film_id_IDX ON inventory (film_id);
CREATE INDEX inventory_store_film_id_IDX ON inventory (store_id,film_id);
CREATE OR REPLACE TRIGGER inventory_timestamp_trigger
    BEFORE UPDATE ON inventory
    FOR EACH ROW
    BEGIN
        :new.last_update := current_timestamp;
    END;
/

CREATE TABLE language (
  language_id NUMBER(5,0) GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
  name CHAR(20) NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT language_PK PRIMARY KEY (language_id),
  CHECK(language_id>0));
CREATE OR REPLACE TRIGGER language_timestamp_trigger
    BEFORE UPDATE ON language
    FOR EACH ROW
    BEGIN
        :new.last_update := current_timestamp;
    END;
/

CREATE TABLE payment (
  payment_id NUMBER(5,0) GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
  customer_id NUMBER(5,0) NOT NULL,
  staff_id NUMBER(3,0) NOT NULL,
  rental_id NUMBER(10,0) DEFAULT NULL,
  amount DECIMAL(5,2) NOT NULL,
  payment_date DATE NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT payment_PK PRIMARY KEY (payment_id),
  CHECK(customer_id>0),
  CHECK(staff_id>0));
CREATE INDEX payment_staff_id_IDX ON payment (staff_id);
CREATE INDEX payment_customer_id_IDX ON payment (customer_id);
CREATE OR REPLACE TRIGGER payment_timestamp_trigger
    BEFORE UPDATE ON payment
    FOR EACH ROW
    BEGIN
        :new.last_update := current_timestamp;
    END;
/

CREATE TABLE rental (
  rental_id NUMBER(10,0) GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
  rental_date DATE NOT NULL,
  inventory_id NUMBER(7,0) NOT NULL,
  customer_id NUMBER(5,0) NOT NULL,
  return_date DATE DEFAULT NULL,
  staff_id NUMBER(3,0) NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT rental_PK PRIMARY KEY (rental_id),
  CHECK(inventory_id>0),
  CHECK(customer_id>0),
  CHECK(staff_id>0));
CREATE INDEX rental_date_inventory_customer_IDX ON rental (rental_date,inventory_id,customer_id);
CREATE INDEX rental_inventory_id_IDX ON rental (inventory_id);
CREATE INDEX rental_customer_id_IDX ON rental (customer_id);
CREATE INDEX rental_staff_id_IDX ON rental (staff_id);
CREATE OR REPLACE TRIGGER rental_timestamp_trigger
    BEFORE UPDATE ON rental
    FOR EACH ROW
    BEGIN
        :new.last_update := current_timestamp;
    END;
/


-- END OF TABLE CREATION







-- ------------------------------------------------------------------------------------

--
-- Triggers for loading film_text from film
--

CREATE TRIGGER ins_film AFTER INSERT ON film FOR EACH ROW BEGIN
    INSERT INTO film_text (film_id, title, description)
        VALUES (:new.film_id, :new.title, :new.description);
  END;
/

CREATE TRIGGER upd_film AFTER UPDATE ON film FOR EACH ROW BEGIN
    IF (:old.title != :new.title) OR (:old.description != :new.description) OR (:old.film_id != :new.film_id)
    THEN
        UPDATE film_text
            SET title=:new.title,
                description=:new.description,
                film_id=:new.film_id
        WHERE film_id=:old.film_id;
    END IF;
  END;
/

CREATE TRIGGER del_film AFTER DELETE ON film FOR EACH ROW BEGIN
    DELETE FROM film_text WHERE film_id = :old.film_id;
  END;
/

-- View structure for view `customer_list`
CREATE VIEW staff_list AS
	SELECT
		s.staff_id AS ID,
		(s.first_name || ' ' || s.last_name) AS name,
		a.address AS address,
		a.postal_code AS zip_code,
		a.phone AS phone,
		city.city AS city,
		country.country AS country,
		s.store_id AS SID
	FROM staff s 
	JOIN address a ON (s.address_id = a.address_id)
	JOIN city ON (a.city_id = city.city_id)
	JOIN country ON (city.country_id = country.country_id);

-- View structure for view `sales_by_film_category`
CREATE VIEW sales_by_film_category AS
	SELECT
		c.name AS category,
		SUM(p.amount) AS total_sales
	FROM payment p
	INNER JOIN rental r ON (p.rental_id = r.rental_id)
	INNER JOIN inventory i ON (r.inventory_id = i.inventory_id)
	INNER JOIN film f ON (i.film_id = f.film_id)
	INNER JOIN film_category fc ON (f.film_id = fc.film_id)
	INNER JOIN category c ON (fc.category_id = c.category_id)
	GROUP BY c.name
	ORDER BY total_sales;

